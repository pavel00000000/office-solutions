<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>✨ Приятный фон</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      user-select: none;
    }
  </style>
</head>
<body>
  <script type="x-shader/x-fragment">#version 300 es
  precision highp float;
  out vec4 O;
  uniform float time;
  uniform vec2 resolution;
  #define FC gl_FragCoord.xy
  #define R resolution
  #define T time
  #define MN min(R.x,R.y)

  void main() {
    vec2 uv = (FC - 0.5 * R) / MN;
    float s = 12.0, e = 9e-4;
    vec3 col = e / (sin(uv.x * s) * cos(uv.y * s)) * vec3(1.0, 0.1, 0.6); // Насыщенный розовый оттенок
    O = vec4(col, 1.0);
}


  </script>

  <script>
    window.onload = init;
    function init() {
      let renderer, canvas;
      const dpr = Math.max(1, devicePixelRatio);
      const resize = () => {
        const { innerWidth: width, innerHeight: height } = window;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        if (renderer) {
          renderer.updateScale(dpr);
        }
      };
      const source = document.querySelector("script[type='x-shader/x-fragment']").textContent;
      canvas = document.createElement("canvas");
      document.body.innerHTML = "";
      document.body.appendChild(canvas);
      renderer = new Renderer(canvas, dpr);
      renderer.setup();
      renderer.init();
      resize();
      if (renderer.test(source) === null) {
        renderer.updateShader(source);
      }
      window.onresize = resize;
      const loop = (now) => {
        renderer.render(now);
        requestAnimationFrame(loop);
      };
      loop(0);
    }

    class Renderer {
      #vertexSrc = `#version 300 es
      precision highp float;
      in vec4 position;
      void main() {
        gl_Position = position;
      }`;

      #fragmtSrc = `#version 300 es
      precision highp float;
      out vec4 O;
      uniform float time;
      uniform vec2 resolution;
      void main() {
        vec2 uv = gl_FragCoord.xy / resolution;
        O = vec4(uv, sin(time) * 0.5 + 0.5, 1.0);
      }`;

      #vertices = [-1, 1, -1, -1, 1, 1, 1, -1];

      constructor(canvas, scale) {
        this.canvas = canvas;
        this.scale = scale;
        this.gl = canvas.getContext("webgl2");
        this.gl.viewport(0, 0, canvas.width * scale, canvas.height * scale);
        this.shaderSource = this.#fragmtSrc;
      }

      get defaultSource() {
        return this.#fragmtSrc;
      }

      updateShader(source) {
        this.reset();
        this.shaderSource = source;
        this.setup();
        this.init();
      }

      updateScale(scale) {
        this.scale = scale;
        this.gl.viewport(0, 0, this.canvas.width * scale, this.canvas.height * scale);
      }

      compile(shader, source) {
        const gl = this.gl;
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
        }
      }

      test(source) {
        let result = null;
        const gl = this.gl;
        const shader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          result = gl.getShaderInfoLog(shader);
        }
        return result;
      }

      reset() {
        const { gl, program, vs, fs } = this;
        if (!program) return;
        if (vs) {
          gl.detachShader(program, vs);
          gl.deleteShader(vs);
        }
        if (fs) {
          gl.detachShader(program, fs);
          gl.deleteShader(fs);
        }
        gl.deleteProgram(program);
      }

      setup() {
        const gl = this.gl;
        this.vs = gl.createShader(gl.VERTEX_SHADER);
        this.fs = gl.createShader(gl.FRAGMENT_SHADER);
        this.compile(this.vs, this.#vertexSrc);
        this.compile(this.fs, this.shaderSource);
        this.program = gl.createProgram();
        gl.attachShader(this.program, this.vs);
        gl.attachShader(this.program, this.fs);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(this.program));
        }
      }

      init() {
        const { gl, program } = this;
        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#vertices), gl.STATIC_DRAW);
        const position = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
        program.resolution = gl.getUniformLocation(program, "resolution");
        program.time = gl.getUniformLocation(program, "time");
      }

      render(now = 0) {
        const { gl, program, buffer, canvas } = this;
        if (!program) return;
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.uniform2f(program.resolution, canvas.width, canvas.height);
        gl.uniform1f(program.time, now * 0.001);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  </script>
</body>
</html>
